using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Xml.Linq;

using Create_Class_from_Table_1;

using SLDisMacros.Interfaces;

public class Script
{
	public const string RecordClassName = "Record";
	public const string RecordsClassName = "Records";
	public const string RecordsPropName = "Rows";

	public static void Run(IEngine engine)
	{
		#region Initialize
		string selectedText = engine.Input.GetSelectedText();

		XDocument xDoc = MacroExtensions.StringToXDocument(selectedText);

		List<string> idxParameters = new List<string>();

		Dictionary<string, ParamOptions> descParameters = new Dictionary<string, ParamOptions>();

		string tableName = String.Empty;

		string tableDescription = String.Empty;

		int pkIndex = -1;

		bool isSNMP = false;

		TabbedStringBuilder text = new TabbedStringBuilder();
		#endregion

		#region Parsing
		IEnumerable<XElement> xParamTags = xDoc.Descendants("Param");

		foreach (XElement xParamTag in xParamTags)
		{
			XElement xTypeTag = xParamTag.Element("Type");

			if (xTypeTag.Value == "array")
			{
				tableName = xParamTag.Element("Name").Value.Filtered();

				tableDescription = xParamTag.Element("Description").Value;

				if (xParamTag.Element("SNMP") != null)
				{
					isSNMP = true;
				}

				pkIndex = Convert.ToInt32(xParamTag.Element("ArrayOptions").Attribute("index").Value);
			}
			else
			{
				if (xTypeTag.Value == "write")
				{
					continue;
				}

				string id = xParamTag.FirstAttribute.Value;

				idxParameters.Add((xParamTag.Element("Name").Value.FirstLetterToLower() + "_" + id).Filtered());

				string sDescription = xParamTag.Element("Description").Value.Replace(" ", String.Empty);

				int index = sDescription.IndexOf('(');

				string propType = xParamTag.Element("Interprete").Element("Type").Value;
				string propOptions = xParamTag.Element("Measurement").Element("Type").Attribute("options")?.Value;

				if (index > 0)
				{
					descParameters.Add(sDescription.Substring(0, index).Filtered(), new ParamOptions
					{
						Type = propType,
						TypeOptions = propOptions,
					});
				}
			}
		}
		#endregion

		#region Writing

		#region addUsingStatements
		text.AppendLine("// <auto-generated>This is auto-generated code by a DIS Macro. Do not modify.</auto-generated>");
		text.AppendLine("namespace Skyline.Protocol.Tables");
		text.OpenCurlyBraces();
		text.AppendLine("using System;");
		text.AppendLine("using System.Collections.Generic;");
		text.AppendLine("using System.Linq;");
		text.AppendLine();
		text.AppendLine("using Skyline.DataMiner.Net.Helper;");
		text.AppendLine("using Skyline.DataMiner.Scripting;");
		text.AppendLine();
		text.AppendLine("using SLNetMessages = Skyline.DataMiner.Net.Messages;");
		text.AppendLine();
		#endregion

		if (descParameters.Count > 0)
		{
			#region addRecord Class
			text.AppendLine("public class " + tableDescription.Replace(" ", "") + RecordClassName);
			text.OpenCurlyBraces();

			text.AppendLine("private static readonly double DateTimeNotAvailable = -2;");
			text.AppendLine();

			#region addFields
			foreach (var propData in descParameters.Where(param => param.Value.TypeOptions != null && param.Value.TypeOptions.Contains("datetime")))
			{
				text.AppendLine($"private DateTime {propData.Key.FirstLetterToLower()};");
			}

			text.AppendLine();
			#endregion

			#region addConstructor
			text.AppendLine($"public {tableDescription.Replace(" ", "")}{RecordClassName}() {{ }}");
			text.AppendLine();

			text.AppendLine($"public {tableDescription.Replace(" ", "")}{RecordClassName}(params object[] row)");
			text.OpenCurlyBraces();

			int index = 0;
			foreach (var propData in descParameters)
			{
				if (propData.Value.TypeOptions != null && propData.Value.TypeOptions.Contains("datetime"))
				{
					text.AppendLine($"{propData.Key.FirstLetterToUpper()} = DateTime.FromOADate(Convert.To{propData.Value.Type.FirstLetterToUpper()}(row[{index}]));");
				}
				else
				{
					text.AppendLine($"{propData.Key.FirstLetterToUpper()} = Convert.To{propData.Value.Type.FirstLetterToUpper()}(row[{index}]);");
				}

				index++;
			}

			text.CloseCurlyBraces();
			text.AppendLine();
			#endregion

			#region addProperties
			foreach (var propData in descParameters)
			{
				if (propData.Value.TypeOptions != null && propData.Value.TypeOptions.Contains("datetime"))
				{
					text.AppendLine("public DateTime " + propData.Key);
					text.OpenCurlyBraces();

					text.AppendLine("get");
					text.OpenCurlyBraces();
					text.AppendLine($"return {propData.Key.FirstLetterToLower()};");
					text.CloseCurlyBraces();
					text.AppendLine();
					text.AppendLine("set");
					text.OpenCurlyBraces();
					text.AppendLine($"{propData.Key.FirstLetterToLower()} = value;");
					text.CloseCurlyBraces();

					text.CloseCurlyBraces();
					text.AppendLine();

					text.AppendLine($"public double {propData.Key}OA");
					text.OpenCurlyBraces();
					text.AppendLine("get");
					text.OpenCurlyBraces();
					text.AppendLine($"if({propData.Key.FirstLetterToLower()} == default)");
					text.OpenCurlyBraces();
					text.AppendLine("return DateTimeNotAvailable;");
					text.CloseCurlyBraces();
					text.AppendLine();
					text.AppendLine($"return {propData.Key.FirstLetterToLower()}.ToOADate();");
					text.CloseCurlyBraces();
					text.CloseCurlyBraces();
					text.AppendLine();
				}
				else
				{
					text.AppendLine("public " + propData.Value.Type + " " + propData.Key + " { get; set; } \n");
				}
			}
			#endregion

			#region addMethods
			List<string> propNames = descParameters.Keys.ToList();
			if (!isSNMP)
			{
				#region addFromPK
				text.AppendLine($"public static {tableDescription.Replace(" ", "")}{RecordClassName} FromPK(SLProtocol protocol, string pk)");
				text.OpenCurlyBraces();
				text.AppendLine("var row = (object[])protocol.GetRow(Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid, pk);");
				text.AppendLine("if(row[0] == null)");
				text.OpenCurlyBraces();
				text.AppendLine("return default;");
				text.CloseCurlyBraces();
				text.AppendLine();
				text.AppendLine($"return new {tableDescription.Replace(" ", "")}{RecordClassName}(row);");
				text.CloseCurlyBraces();
				#endregion

				text.AppendLine();

				#region addToProtocolRow
				text.AppendLine("public object[] ToProtocolRow()");
				text.OpenCurlyBraces();
				text.AppendLine("return new " + tableName.ToLower().FirstLetterToUpper() + "QActionRow");
				text.OpenCurlyBraces();
				for (int i = 0; i < idxParameters.Count; i++)
				{
					var param = descParameters.ElementAt(i);
					if (param.Value.TypeOptions != null && param.Value.TypeOptions.Contains("datetime"))
					{
						text.AppendLine(idxParameters[i].ToLower().FirstLetterToUpper() + " = " + param.Key + "OA,");
					}
					else
					{
						text.AppendLine(idxParameters[i].ToLower().FirstLetterToUpper() + " = " + propNames[i] + ",");
					}
				}
				text.CloseCurlyBraces(false);
				text.AppendLine(";");
				text.CloseCurlyBraces();
				#endregion

				text.AppendLine();

				#region addSaveToProtocol
				text.AppendLine("public void SaveToProtocol(SLProtocol protocol)");
				text.OpenCurlyBraces();
				text.AppendLine("if(!protocol.Exists(Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid, " + descParameters.First().Key + "))");
				text.OpenCurlyBraces();
				text.AppendLine("protocol.AddRow(Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid, ToProtocolRow());");
				text.CloseCurlyBraces();
				text.AppendLine("else");
				text.OpenCurlyBraces();
				text.AppendLine("protocol.SetRow(Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid, " + descParameters.First().Key + ", ToProtocolRow());");
				text.CloseCurlyBraces();
				text.CloseCurlyBraces();
				#endregion
			}
			text.CloseCurlyBraces();
			#endregion

			#endregion

			text.AppendLine();

			#region AddRecordsClass
			text.AppendLine("public class " + tableDescription.Replace(" ", "") + RecordsClassName);
			text.OpenCurlyBraces();

			#region Constructor
			text.AppendLine("public " + tableDescription.Replace(" ", "") + RecordsClassName + "() { }");
			text.AppendLine();

			AddConstructorRecord(idxParameters, descParameters, tableName, tableDescription, text);
			#endregion

			#region AddProps
			text.AppendLine("public List<" + tableDescription.Replace(" ", "") + RecordClassName + "> " + RecordsPropName + " { get; set; } = new List<" + tableDescription.Replace(" ", "") + RecordClassName + ">();\n");
			#endregion

			#region SaveToProtocol
			if (!isSNMP)
			{
				text.AppendLine("public void SaveToProtocol(SLProtocol protocol, bool partial = false)");
				text.OpenCurlyBraces();
			
				text.AppendLine("// Calculate the batch size, recommended 25000 cells max per fill array, divided by the number of columns.");
				text.AppendLine($"var batchSize = 25000 / {descParameters.Count};");
				text.AppendLine();
				text.AppendLine("// When full updating and the Rows are empty, clear the table.");
				text.AppendLine($"if (!Rows.Any() && !partial)");
				text.OpenCurlyBraces();
				text.AppendLine("protocol.ClearAllKeys(Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid);");
				text.AppendLine("return;");
				text.CloseCurlyBraces();
				text.AppendLine();
				text.AppendLine("// If full then the first batch needs to be a SaveOption.Full.");

				text.AppendLine($"var rowObjectArray = Rows.Select(x => x.ToProtocolRow());");
				text.AppendLine("foreach (var batch in rowObjectArray.Batch(batchSize))");
				text.OpenCurlyBraces();

				text.AppendLine($"protocol.FillArray(Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid, batch.ToList(), NotifyProtocol.SaveOption.Partial);");

				text.CloseCurlyBraces();
				text.AppendLine();
				text.AppendLine($"var keys = protocol.GetKeys(Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid);");
				text.AppendLine($"var updatedKeys = rowObjectArray.Select(x => Convert.ToString(x[{pkIndex}]));");
				text.AppendLine($"protocol.DeleteRow(Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid,keys.Except(updatedKeys).ToArray());");

				text.CloseCurlyBraces();
			}

			#endregion

			text.CloseCurlyBraces();
			text.CloseCurlyBraces();

			#endregion

			Clipboard.SetText(text.ToString());

			//Clipboard.SetText("enum MyEnum { NA = -1, " + String.Join(", ", enumItems) + " };");

			engine.LogToOutputWindow("enum variable has been placed in the clipboard.");
		}
		else
		{
			engine.LogToOutputWindow("Could not find any correctly defined Discreet in the selected input text.");
		}

		engine.LogToOutputWindow("Classes have been placed in the clipboard.");
	}

	private static void AddConstructorRecord(List<string> idxParameters, Dictionary<string, ParamOptions> descParameters, string tableName, string tableDescription, TabbedStringBuilder text)
	{
		text.AppendLine("public " + tableDescription.Replace(" ", "") + RecordsClassName + "(SLProtocol protocol)");
		text.OpenCurlyBraces();

		text.AppendLine("uint[] " + tableName.FirstLetterToLower() + "Idx = new uint[]");
		text.OpenCurlyBraces();

		foreach (var idxParam in idxParameters)
		{
			text.AppendLine("Parameter." + tableName.ToLower().FirstLetterToUpper() + ".Idx." + idxParam.ToLower() + ",");
		}

		//text.Remove(text.Length - 1, 1);

		text.Remove(text.Length - 1, 1);

		text.CloseCurlyBraces(false);
		text.RawAppendLine(";");

		text.AppendLine("object[] " + tableDescription.Replace(" ", "").ToLower() +

			" = (object[])protocol.NotifyProtocol((int)SLNetMessages.NotifyType.NT_GET_TABLE_COLUMNS, Parameter." + tableName.ToLower().FirstLetterToUpper() + ".tablePid, " + tableName.FirstLetterToLower() + "Idx);");

		int i = 0;

		foreach (var descPmt in descParameters.Keys)
		{
			text.AppendLine("object[] " + descPmt.FirstLetterToLower() + " = (object[])" + tableDescription.Replace(" ", "").ToLower() + "[" + i + "];");

			i += 1;
		}

		text.AppendLine();

		//loop to add records to the list
		text.AppendLine("for (int i = 0; i < " + descParameters.Keys.First().FirstLetterToLower() + ".Length; i++)");
		text.OpenCurlyBraces();
		text.AppendLine(RecordsPropName + ".Add( new " + tableDescription.Replace(" ", "") + RecordClassName + "(");
		i = 0;
		foreach (var propdata in descParameters)
		{
			if (i != 0)
				text.RawAppendLine(",");
			text.Append(propdata.Key.FirstLetterToLower() + "[i]");
			i++;
		}

		text.AppendLine("));");
		text.CloseCurlyBraces();
		text.CloseCurlyBraces();
		text.AppendLine();
	}
	#endregion
}

namespace Create_Class_from_Table_1
{
	using System.Text.RegularExpressions;

	public class ParamOptions
	{
		public string Type { get; set; }

		public string TypeOptions { get; set; }
	}

	public static class MacroExtensions
	{
		public static string GetSelectedText(this IMacroInput input)
		{
			List<string> selectedTextParts = new List<string>();

			foreach (var selectedSpan in input.SelectedTextSpans)
			{
				selectedTextParts.Add(selectedSpan.Text);
			}

			return String.Join(null, selectedTextParts);
		}

		public static XDocument StringToXDocument(string text)
		{
			XDocument xDoc;

			try
			{
				xDoc = XDocument.Parse(text);
			}
			catch (Exception)
			{
				xDoc = XDocument.Parse("<TempRoot>" + text + "</TempRoot>");
			}

			return xDoc;
		}
	}

	public static class StringExtensions
	{
		public static string Filtered(this string str)
		{
			return Regex.Replace(str, @"\W+", "");   // trim non-word characters
		}

		public static string FirstLetterToLower(this string input)
		{
			switch (input)
			{
				case null:

					throw new ArgumentNullException(nameof(input));

				case "":

					throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input));

				default:

					return input.First().ToString().ToLower() + input.Substring(1);
			}
		}

		public static string FirstLetterToUpper(this string input)
		{
			switch (input)
			{
				case null:

					throw new ArgumentNullException(nameof(input));

				case "":

					throw new ArgumentException($"{nameof(input)} cannot be empty", nameof(input));

				default:

					return input.First().ToString().ToUpper() + input.Substring(1);
			}
		}
	}

	public class TabbedStringBuilder
	{
		private int tabIndex = 0;
		private readonly StringBuilder sb = new StringBuilder();

		public int Length { get => sb.Length; }

		public TabbedStringBuilder RawAppend(string line)
		{
			sb.Append(line);
			return this;
		}

		public TabbedStringBuilder Append(string line)
		{
			sb.Append(new String('\t', tabIndex));
			sb.Append(line);
			return this;
		}

		public TabbedStringBuilder RawAppendLine(string line)
		{
			sb.Append(line);
			sb.Append(Environment.NewLine);
			return this;
		}

		public TabbedStringBuilder AppendLine()
		{
			sb.Append(Environment.NewLine);
			return this;
		}

		public TabbedStringBuilder AppendLine(string line)
		{
			sb.Append(new String('\t', tabIndex));
			sb.Append(line);
			sb.Append(Environment.NewLine);
			return this;
		}

		public TabbedStringBuilder OpenCurlyBraces()
		{
			sb.Append(new String('\t', tabIndex));
			sb.Append("{");
			sb.Append(Environment.NewLine);
			tabIndex++;
			return this;
		}

		public TabbedStringBuilder CloseCurlyBraces(bool newLine = true)
		{
			tabIndex--;
			sb.Append(new String('\t', tabIndex));
			sb.Append("}");
			if (newLine)
				sb.Append(Environment.NewLine);
			return this;
		}

		public TabbedStringBuilder Remove(int startIndex, int length)
		{
			sb.Remove(startIndex, length);
			return this;
		}

		public override string ToString()
		{
			return sb.ToString();
		}
	}
}
